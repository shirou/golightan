Token.Comment.Single	u'// Branching with `if` and `else` in Go is\n'
Token.Comment.Single	u'// straight-forward.\n'
Token.Text	u'\n'
Token.Keyword.Namespace	u'package'
Token.Text	u' '
Token.Name.Other	u'main'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Keyword.Namespace	u'import'
Token.Text	u' '
Token.Literal.String	u'"fmt"'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Keyword.Declaration	u'func'
Token.Text	u' '
Token.Name.Other	u'main'
Token.Punctuation	u'('
Token.Punctuation	u')'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Comment.Single	u"// Here's a basic example.\n"
Token.Text	u'\t'
Token.Keyword	u'if'
Token.Text	u' '
Token.Literal.Number.Integer	u'7'
Token.Operator	u'%'
Token.Literal.Number.Integer	u'2'
Token.Text	u' '
Token.Operator	u'=='
Token.Text	u' '
Token.Literal.Number.Integer	u'0'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Literal.String	u'"7 is even"'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u' '
Token.Keyword	u'else'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Literal.String	u'"7 is odd"'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Comment.Single	u'// You can have an `if` statement without an else.\n'
Token.Text	u'\t'
Token.Keyword	u'if'
Token.Text	u' '
Token.Literal.Number.Integer	u'8'
Token.Operator	u'%'
Token.Literal.Number.Integer	u'4'
Token.Text	u' '
Token.Operator	u'=='
Token.Text	u' '
Token.Literal.Number.Integer	u'0'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Literal.String	u'"8 is divisible by 4"'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Comment.Single	u'// A statement can precede conditionals; any variables\n'
Token.Text	u'\t'
Token.Comment.Single	u'// declared in this statement are available in all\n'
Token.Text	u'\t'
Token.Comment.Single	u'// branches.\n'
Token.Text	u'\t'
Token.Keyword	u'if'
Token.Text	u' '
Token.Name.Other	u'num'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Literal.Number.Integer	u'9'
Token.Punctuation	u';'
Token.Text	u' '
Token.Name.Other	u'num'
Token.Text	u' '
Token.Punctuation	u'<'
Token.Text	u' '
Token.Literal.Number.Integer	u'0'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Name.Other	u'num'
Token.Punctuation	u','
Token.Text	u' '
Token.Literal.String	u'"is negative"'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u' '
Token.Keyword	u'else'
Token.Text	u' '
Token.Keyword	u'if'
Token.Text	u' '
Token.Name.Other	u'num'
Token.Text	u' '
Token.Punctuation	u'<'
Token.Text	u' '
Token.Literal.Number.Integer	u'10'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Name.Other	u'num'
Token.Punctuation	u','
Token.Text	u' '
Token.Literal.String	u'"has 1 digit"'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u' '
Token.Keyword	u'else'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Name.Other	u'num'
Token.Punctuation	u','
Token.Text	u' '
Token.Literal.String	u'"has multiple digits"'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Keyword.Declaration	u'func'
Token.Text	u' '
Token.Name.Other	u'rangeExample'
Token.Punctuation	u'('
Token.Punctuation	u')'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Comment.Single	u'// Here we use `range` to sum the numbers in a slice.\n'
Token.Text	u'\t'
Token.Comment.Single	u'// Arrays work like this too.\n'
Token.Text	u'\t'
Token.Name.Other	u'nums'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Punctuation	u'['
Token.Punctuation	u']'
Token.Keyword.Type	u'int'
Token.Punctuation	u'{'
Token.Literal.Number.Integer	u'2'
Token.Punctuation	u','
Token.Text	u' '
Token.Literal.Number.Integer	u'3'
Token.Punctuation	u','
Token.Text	u' '
Token.Literal.Number.Integer	u'4'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Name.Other	u'sum'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Literal.Number.Integer	u'0'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Keyword	u'for'
Token.Text	u' '
Token.Name.Other	u'_'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'num'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Keyword	u'range'
Token.Text	u' '
Token.Name.Other	u'nums'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'sum'
Token.Text	u' '
Token.Operator	u'+='
Token.Text	u' '
Token.Name.Other	u'num'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Literal.String	u'"sum:"'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'sum'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Comment.Single	u'// `range` on arrays and slices provides both the\n'
Token.Text	u'\t'
Token.Comment.Single	u"// index and value for each entry. Above we didn't\n"
Token.Text	u'\t'
Token.Comment.Single	u'// need the index, so we ignored it with the\n'
Token.Text	u'\t'
Token.Comment.Single	u'// blank identifier `_`. Sometimes we actually want\n'
Token.Text	u'\t'
Token.Comment.Single	u'// the indexes though.\n'
Token.Text	u'\t'
Token.Keyword	u'for'
Token.Text	u' '
Token.Name.Other	u'i'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'num'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Keyword	u'range'
Token.Text	u' '
Token.Name.Other	u'nums'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Keyword	u'if'
Token.Text	u' '
Token.Name.Other	u'num'
Token.Text	u' '
Token.Operator	u'=='
Token.Text	u' '
Token.Literal.Number.Integer	u'3'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Literal.String	u'"index:"'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'i'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Comment.Single	u'// `range` on map iterates over key/value pairs.\n'
Token.Text	u'\t'
Token.Name.Other	u'kvs'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Keyword.Declaration	u'map'
Token.Punctuation	u'['
Token.Keyword.Type	u'string'
Token.Punctuation	u']'
Token.Keyword.Type	u'string'
Token.Punctuation	u'{'
Token.Literal.String	u'"a"'
Token.Punctuation	u':'
Token.Text	u' '
Token.Literal.String	u'"apple"'
Token.Punctuation	u','
Token.Text	u' '
Token.Literal.String	u'"b"'
Token.Punctuation	u':'
Token.Text	u' '
Token.Literal.String	u'"banana"'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Keyword	u'for'
Token.Text	u' '
Token.Name.Other	u'k'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'v'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Keyword	u'range'
Token.Text	u' '
Token.Name.Other	u'kvs'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Printf'
Token.Punctuation	u'('
Token.Literal.String	u'"%s -> %s\\n"'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'k'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'v'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Comment.Single	u'// `range` can also iterate over just the keys of a map.\n'
Token.Text	u'\t'
Token.Keyword	u'for'
Token.Text	u' '
Token.Name.Other	u'k'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Keyword	u'range'
Token.Text	u' '
Token.Name.Other	u'kvs'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Literal.String	u'"key:"'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'k'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Comment.Single	u'// `range` on strings iterates over Unicode code\n'
Token.Text	u'\t'
Token.Comment.Single	u'// points. The first value is the starting byte index\n'
Token.Text	u'\t'
Token.Comment.Single	u'// of the `rune` and the second the `rune` itself.\n'
Token.Text	u'\t'
Token.Keyword	u'for'
Token.Text	u' '
Token.Name.Other	u'i'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'c'
Token.Text	u' '
Token.Operator	u':='
Token.Text	u' '
Token.Keyword	u'range'
Token.Text	u' '
Token.Literal.String	u'"go"'
Token.Text	u' '
Token.Punctuation	u'{'
Token.Text	u'\n'
Token.Text	u'\t\t'
Token.Name.Other	u'fmt'
Token.Punctuation	u'.'
Token.Name.Other	u'Println'
Token.Punctuation	u'('
Token.Name.Other	u'i'
Token.Punctuation	u','
Token.Text	u' '
Token.Name.Other	u'c'
Token.Punctuation	u')'
Token.Text	u'\n'
Token.Text	u'\t'
Token.Punctuation	u'}'
Token.Text	u'\n'
Token.Punctuation	u'}'
Token.Text	u'\n'
